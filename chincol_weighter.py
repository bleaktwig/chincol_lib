# No preamble _on purpose_. This should be ran with the python version in your
#     virtual environment!

from copy import deepcopy
import numpy as np
from daemonflux import Flux

# Daemon processes nu flavors as strings, so we dispatch int -> str.
PID_DISPATCH = {
    12: "nue",   -12: "antinue",
    14: "numu",  -14: "antinumu"
}

# Daemon parameters fitted to match honda by Anil.
HONDA_PARAMS  = {
    "K+_158G"  : 0.26271344011862174,  "K+_2P"    : 1.5146609250529792,
    "K+_31G"   : -0.23796722643365875, "K-_158G"  : 0.22562701740371072,
    "K-_2P"    : 1.5795586499318395,   "K-_31G"   : -0.0636889438625996,
    "n_158G"   : 0.0548762346807683,   "n_2P"     : -0.0078116110471464495,
    "p_158G"   : 0.03498461969924804,  "p_2P"     : -0.03945134038254006,
    "pi+_158G" : -0.21710827498752083, "pi+_20T"  : -0.9371687069575185,
    "pi+_2P"   : 0.08159661213177705,  "pi+_31G"  : 0.13460564732303393,
    "pi-_158G" : -0.09343601223371412, "pi-_20T"  : -0.9731623451110765,
    "pi-_2P"   : -0.22351132607607882, "pi-_31G"  : -0.12052452576550632,
    "GSF_1"    : 0.22245586136547857,  "GSF_2"    : 0.007757402919801315,
    "GSF_3"    : 0.002712680005964252, "GSF_4"    : 0.012697469836919772,
    "GSF_5"    : -0.04626193190376027, "GSF_6"    : 0.02367471695611645
}

# Constants used to compute oscillation probabilities.
L1   = 19.
R    = 6378.2 + L1
AMP  = 1.
DM31 = 0.0024484266973546576

def calc_wgen(
    w_one: np.ndarray, n_evts: int, type: float = 0.5
) -> np.ndarray:
    """
    Calculates generated weights following the formula:
        GeneratedWeight = OneWeight / (type * n_events).
    For an explanation of this, please see:
        https://wiki.icecube.wisc.edu/index.php/Weights_in_nugen_Simulation_Data

    Args:
        w_one   : List containing the OneWeight for each generated neutrino.
        n_evts  : Number of events. We assume that this _includes_ the number of
                  files, such that n_evts is the sum of events for all the files
                  we're working with.
        type    : Type of weight, depending on the way we are considering neu-
                  trino and antineutrino flux. If they are to be evaluated sepa-
                  rately (together), this should be .5 (1.).

    Returns:
        List of generated weights in cm^2 sr GeV.
    """
    return w_one / (type * n_evts)

def calc_wflux_daemon(
    energy: np.ndarray, zenith: np.ndarray, pdg: np.ndarray,
    in_deg: bool = False, honda: bool = False
) -> np.ndarray:
    """
    Initializes a Flux instance (from daemonflux) and calculates flux weight for
    a distribution of neutrinos using their energy, zenith, and pdg.

    Args:
        energy : List with the particles' energy.
        zenith : List with the particles' zenith angle.
        pdg    : List with the particles' PID in the PDG system.
        in_deg : True if the zenith angle comes in degrees, False if it's in
                 radians.
        honda  : True if we want to use the honda parameters, False to use the
                 default daemon calibration parameters.

    Returns:
        List of flux weights in GeV^-1 s^-1 sr^-1 cm^-2.
    """
    # Assert that all lists are of the same size.
    if len({len(l) for l in [energy, zenith, pdg]}) != 1:
        raise ValueError("Input lists should be of the same size.")

    # Convert zenith to degrees if necessary.
    if not in_deg: zenith = [np.rad2deg(z) for z in zenith]

    wflux = []
    if not honda:
        df = Flux(location = "IceCube", use_calibration = True)
        for (e, z, p) in zip(energy, zenith, pdg):
            wflux.append(df.flux(e, z, PID_DISPATCH[p]))
    else:
        df = Flux(location = "IceCube")
        for (e, z, p) in zip(energy, zenith, pdg):
            wflux.append(df.flux(e, z, PID_DISPATCH[p], params=HONDA_PARAMS))

    # daemon reports flux * E^3, so we have to readjust.
    return np.array([wf / pow(e, 3) for (wf, e) in zip(wflux, energy)])

def calc_wosc_2fm(
    energy: np.ndarray, zenith: np.ndarray, pdg: np.ndarray, type: np.ndarray,
    wflux: np.ndarray,
) -> np.ndarray:
    """
    Calculates oscillation probabilities in 2-flavor mode and compounts them to
    flux weights from a set of neutrinos. In 2-flavor mode,
      * NC are flavor-blind;
      * nu_e doesn't oscillate in 2-flavor mode;
      * nu_mu is all disappearance; and
      * nu_tau is all appearance -- it was assigned nu_mu flux.

    Args:
        energy : List with the particles' energy.
        zenith : List with the particles' zenith angle.
        pdg    : List with the particles' PID in the PDG system.
        type   : List with the particles' type, as generated by GENIE.
        wflux  : List with the particles' flux weights.

    Returns:
        A list with the flux weights updated with the oscilation probabilities.
    """
    # Assert that all lists are of the same size.
    if len({len(l) for l in [energy, zenith, pdg, type, wflux]}) != 1:
        raise ValueError("Input lists should be of same size.")

    # Tag each flavor (NC have their own category).
    tag_nunc = type == 0
    tag_nuecc   = (np.abs(pdg) == 12) * (~tag_nunc)
    tag_numucc  = (np.abs(pdg) == 14) * (~tag_nunc)
    tag_nutaucc = (np.abs(pdg) == 16) * (~tag_nunc)

    # Compute propagation distance.
    psi = zenith - np.arcsin((1 - L1/R) * np.sin(zenith))
    prop_distance = np.sqrt((R-L1)**2 + R**2 - (2 * (R-L1) * R * np.cos(psi)))

    # Get transition probability.
    ptau = AMP * np.sin(1.267 * DM31 * prop_distance / energy)**2

    # Obtain oscillation flux
    wosc = np.zeros_like(energy)
    wosc[tag_nunc]    = deepcopy(wflux[tag_nunc])
    wosc[tag_nuecc]   = deepcopy(wflux[tag_nuecc])
    wosc[tag_numucc]  = deepcopy(wflux[tag_numucc]*(1-ptau[tag_numucc]))
    wosc[tag_nutaucc] = deepcopy(wflux[tag_nutaucc]*ptau[tag_nutaucc])

    return wosc
